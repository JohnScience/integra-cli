/// Build scripts have long served for the benefit of Rust.
/// Coordinated by Cargo, they allowed Rust programmers to do almost all the jobs
/// that Integra aims to do. For example, to create Rust bindings to C libraries
/// a build script could use 'cc' crate and do this. Some artifacts from Rust code could
/// be generated by analyzing the Rust code with 'syn' crate and then looked up.
/// 
/// However, these two distinct goals (importing and exporting of artifacts) were not explicit
/// in build scripts. Moreover, syncronization of data in different forms (in the Rust crate and outside)
/// was technically possible but in fact abused the functionality of build scripts, making such name a misnomer.
/// 
/// One more reason why Rust needed a tool like Integra is that Rust crates is not the only form of an artifact
/// with which Rust programmers have to deal with. With the advent of evxcr, Jupyter notebook for evxcr kernel is
/// one more option.

// concat! macro can work only with string literals
macro_rules! get_template_lowercase_name {
    (GenericConfigTemplateZST) => { "generic" };
}

macro_rules! get_template_file_name_by_lowercase_name {
    ($template_lowercase_name:expr) => {
        concat!($template_lowercase_name, ".template.toml" )
    };
}

macro_rules! get_template_file_name_by_template_type {
    (GenericConfigTemplateZST) => {
        get_template_file_name_by_lowercase_name!(get_template_lowercase_name!(GenericConfigTemplateZST))
    };
}

// The macro relies on the relative position of the call site with respect to the config_templates directory
macro_rules! get_relative_path_to_template_file_by_template_type {
    (GenericConfigTemplateZST) => {
        // std::path::MAIN_SEPARATOR is not a literal but an expression
        // At the time of writing, host-specific conditional compilation is NOT required
        // because "/" separator works on all platforms if windows is not using long-path syntax
        concat!("config_templates", "/", get_template_file_name_by_template_type!(GenericConfigTemplateZST))
    };
}

pub enum ConfigTemplates {
    Generic(GenericConfigTemplateZST),
}

impl ConfigTemplates {
    pub fn get_config_path_by_crate_path(crate_path :&str) -> String {
        format!("{}{}Integra.toml", crate_path, std::path::MAIN_SEPARATOR)
    }

    pub const fn get_lowercase_name(&self) -> &'static str {
        match self {
            ConfigTemplates::Generic(_) => GenericConfigTemplateZST::get_lowercase_name(),
        }
    }

    pub fn try_write_config_template_on_fs(&self, crate_path: &str) -> Result<(), std::io::Error> {
        use std::io::Write;
        let mut file = std::fs::File::create(Self::get_config_path_by_crate_path(crate_path))?;
        match self {
            ConfigTemplates::Generic(_) => file.write_all(include_bytes!(get_relative_path_to_template_file_by_template_type!(GenericConfigTemplateZST))),
        }
    }

    // Internally calls try_write_config_template_on_fs, handles errors and reports the result
    pub fn generate_config_template(&self, crate_path: &str) {
        match self.try_write_config_template_on_fs(crate_path) {
            Ok(_) => println!(
                "{titlecase_attributive_adjective_phrase} Integra template generated at {config_path}",
                // https://en.wikipedia.org/wiki/Adjective_phrase#Attributive_vs._predicative
                titlecase_attributive_adjective_phrase = {
                    voca_rs::case::capitalize(self.get_lowercase_name(), /* rest_to_lower = */ false)
                },
                config_path = Self::get_config_path_by_crate_path(crate_path)
            ),
            Err(e) => match e.kind() {
                // Before generate_config_template() was called, the validator check_if_lacks_integra_config()
                //  ensured integra config wasn't available
                std::io::ErrorKind::AlreadyExists => unreachable!(),
                std::io::ErrorKind::PermissionDenied => eprintln!("Permission denied: {}", e.to_string()),
                _ => eprintln!("Unexpected I/O error: {}", e.to_string()),
            }
        }
    }

    pub fn generate_config_template_by_lowercase_name(name: &str, crate_path :&str) {
        // println!("generate_config_template_by_lowercase_name");
        match name {
            get_template_lowercase_name!(GenericConfigTemplateZST) => ConfigTemplates::Generic(GenericConfigTemplateZST {} ),
            // https://docs.rs/clap/latest/clap/struct.Arg.html#method.possible_values guarantees that
            //  only permissible values are accepted.
            _ => unreachable!(),
        }.generate_config_template(crate_path)
    }
}

// https://runrust.miraheze.org/wiki/Zero-sized_type
pub struct GenericConfigTemplateZST;

impl GenericConfigTemplateZST {
    // TODO: generate the methods
    pub const fn get_lowercase_name() -> &'static str { get_template_lowercase_name!(GenericConfigTemplateZST) }
    pub const fn get_template_file_name() -> &'static str { get_template_file_name_by_template_type!(GenericConfigTemplateZST) }
    pub const fn as_enum_variant() -> ConfigTemplates { ConfigTemplates::Generic(GenericConfigTemplateZST {}) }
    pub const fn get_template_file_contents() -> &'static str {
        // std::path::MAIN_SEPARATOR is not a literal but an expression
        // At the time of writing, host-specific conditional compilation is NOT required
        // because "/" separator works on all platforms if windows is not using long-path syntax
        include_str!(concat!("config_templates", "/", get_template_file_name_by_template_type!(GenericConfigTemplateZST)))
    }
}